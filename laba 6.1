'''
2 часть – усложнить написанную программу, введя по своему усмотрению в условие минимум одно ограничение на характеристики объектов (которое будет сокращать количество переборов)  и целевую функцию для нахождения оптимального  решения.
Вариант 17. На плоскости задано К точек. Сформировать все возможные варианты выбора множества точек из них на проверку того, что они принадлежат одной прямой.
'''

import itertools
import time

# Генерация всех возможных комбинаций точек
def generate_point_combinations(points):
    combinations = []
    for r in range(2, len(points) + 1):  # Рассматриваем комбинации из 2 и более точек
        combinations.extend(list(itertools.combinations(points, r)))
    return combinations

# Проверка, лежат ли точки на одной прямой
def are_points_collinear(points):
    if len(points) < 3:
        return True  # Любые две точки считаются лежащими на одной прямой
    x_values = [point[0] for point in points]
    y_values = [point[1] for point in points]
    return len(set(x_values)) == 1 or len(set(y_values)) == 1 or len(set((x_values[i] - x_values[0]) / (y_values[i] - y_values[0]) for i in range(1, len(points)))) == 1

# Точки для тестирования
points = [(1, 7), (2, 18), (3, 3), (1, 4), (10, 15), (80, 64), (120, 100)]

# Алгоритмический подход
start_time = time.time()
combinations: list = generate_point_combinations([point for point in points if len([p for p in points if p[0] == point[0]]) == 1])  # Учитываем только точки с различными x-координатами
collinear_points = [points for points in combinations if are_points_collinear(points)]
algorithmic_time = time.time() - start_time

# Подход с использованием функций Python
start_time = time.time()
combinations: list = generate_point_combinations([point for point in points if len([p for p in points if p[0] == point[0]]) == 1])  # Учитываем только точки с различными x-координатами
collinear_points = [points for points in combinations if are_points_collinear(points)]
python_functions_time = time.time() - start_time

print("Время выполнения алгоритмического подхода:", algorithmic_time)
print("Время выполнения подхода с использованием функций Python:", python_functions_time)
