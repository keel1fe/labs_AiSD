import itertools
import time

# Генерация всех возможных комбинаций точек
def generate_point_combinations(points):
    combinations = []
    for i in range(2, len(points) + 1):  # Рассматриваем комбинации из 2 и более точек
        combinations.extend(list(itertools.combinations(points, i)))
    return combinations

# Проверка, лежат ли точки на одной прямой
def are_points_collinear(points):
    if len(points) < 3:
        return True  # Любые две точки считаются лежащими на одной прямой
    x_values = [point[0] for point in points]
    y_values = [point[1] for point in points]
    return len(set(x_values)) == 1 or len(set(y_values)) == 1 or len(set((x_values[i] - x_values[0]) / (y_values[i] - y_values[0]) for i in range(1, len(points)))) == 1

# Точки для тестирования
points = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]

# Алгоритмический подход
start_time = time.time()
combinations = generate_point_combinations([point for point in points if len([p for p in points if p[0] == point[0]]) == 1])  # Учитываем только точки с различными x-координатами
collinear_points = [points for points in combinations if are_points_collinear(points)]
algorithmic_time = time.time() - start_time

# Подход с использованием функций Python
start_time = time.time()
combinations = [points for r in range(2, len(points) + 1) for points in itertools.combinations([point for point in points if len([p for p in points if p[0] == point[0]]) == 1], r)]  # Учитываем только точки с различными x-координатами
collinear_points = [points for points in combinations if are_points_collinear(points)]
python_functions_time = time.time() - start_time

print("Время выполнения алгоритмического подхода:", algorithmic_time)
print("Время выполнения подхода с использованием функций Python:", python_functions_time)
